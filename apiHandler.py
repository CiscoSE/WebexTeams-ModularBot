"""
Copyright (c) 2018 Cisco and/or its affiliates.

This software is licensed to you under the terms of the Cisco Sample
Code License, Version 1.0 (the "License"). You may obtain a copy of the
License at

               https://developer.cisco.com/docs/licenses

All use of the material herein must be in accordance with the terms of
the License. All rights not expressly granted by the License are
reserved. Unless required by applicable law or agreed to separately in
writing, software distributed under the License is distributed on an "AS
IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
or implied.
"""

"""
This file contains code to process the incoming messages from Webex Teams and call the appropriate handlers

"""
import os
import apiConfig
import logging
from flask import Flask, request
import CiscoDNA.dnaCenter
import CiscoWebex.webexTeams
import json


"""
/**********************************************************************************************************************
BEGIN Configure logging:
Define the default level (also used for console logging) as well as the level for the logfile
Valid levels from highest to lowest severity are:
    logging.CRITICAL
    logging.ERROR
    logging.WARNING
    logging.INFO
    logging.DEBUG
    
Remember that the defined logging level will also display events for all higher severity levels.
"""
# Logging level for the console logger
loglevel = logging.getLevelName(logging.DEBUG)

# Logging level for logfile
loglevelfile = logging.getLevelName(logging.INFO)

# Initialize a new logging instance for our app
logger = logging.getLogger(apiConfig.logname)
logger.setLevel(loglevel)
#logger.addHandler(default_handler)

# Define the format for console and file log messages
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Configure console logging
ch = logging.StreamHandler()
ch.setLevel(loglevel)
# add formatter to the console handler
ch.setFormatter(formatter)
# add console handler to the root logger
logger.addHandler(ch)

# Configure file logging
fh = logging.FileHandler(apiConfig.logfile)
fh.setLevel(loglevelfile)
fh.setFormatter(formatter)
logger.addHandler(fh)

"""
END Configure Logging
/**********************************************************************************************************************
"""

"""
/**********************************************************************************************************************
BEGIN Pre-flight checks
Add any sanity checks here to ensure the remainder of the script can execute properly
"""

# Verify the temporary path exists
if os.path.isdir(apiConfig.tmpdir) != True:
    logger.info("Temporary path doesn't exist, creating...")
    try:
        os.mkdir(apiConfig.tmpdir)
    except IOError:
        logger.critical("Unable to create temporary path.  Exiting!")
        exit(255)

"""
END Pre-flight checks
/**********************************************************************************************************************
"""

"""
/**********************************************************************************************************************
BEGIN Flask app initialization
The name of this flask app will be referenced in the UWSGI application server configuration
"""

app = Flask(__name__)

"""
END Flask app initialization
/**********************************************************************************************************************
"""


"""
/**********************************************************************************************************************
BEGIN Function definitions
"""


def removeFile(filename):
    """
    Remove file from local filesystem
    :param filename: Full path of the file to remove
    :return: True if file removed, False otherwise.
    """
    retval = False
    try:
        logger.debug("Removing file: %s", filename)
        os.remove(filename)
        retval = True
    except OSError as e:  ## if failed, report it back to the user ##
        logger.error("Error: %s - %s.", e.filename, e.strerror)
    logger.debug("Removed file %s", filename)
    return retval

def parseResponse(teamobj, roomid, response):
    """
    Parse response dictionary generated by package calls and perform the appropriate
    response via Webex Teams (send messages, attach files, etc)
    See the integration section of the README for dictionary structure
    :param teamobj: Reference to the Webex Teams object for messaging
    :param roomid: Where to send messages or file attachments
    :param response: The API response value returned by methods in external packages.  See README for details.
    :return: True if response successfully processed, False otherwise.
    """
    retval = False
    logger.debug("Parsing response from called package.  Response value:\n\t%s", response)

    """
    If the received response is False, there was a problem somewhere along the line and we won't be able
    to process it.  If not false, we should have a valid API response structure and can do something with it. 
    """
    if response != False:
        if response['responseType'] == 'error':
            """
            Our package gave an error.  Create a text and rich text message then reply via Webex Teams.
            """
            logger.warning("There was a problem performing the requested task - check log file for details")

            errmsg = "{}\nThere was a problem performing the requested task.".format('\U0001F92E')
            errmsg += "The error message is:\n{}".format(response['data']['message'])

            errmsgrich = "{}\n\nThere was a problem performing the requested task.".format('\U0001F92E')
            errmsgrich += "The error message is:\n\n{}".format(response['data']['richmessage'])

            teamobj.sendMessage(roomid, errmsg, richmessage=errmsgrich)
        elif response['responseType'] == 'message':
            """
            The package returned a message to be sent to the requestor via Webex Teams.
            """
            logger.debug("Sending message.\n\tRoom: %s\n\tMessage:%s", roomid, response['data']['message'])
            if teamobj.sendMessage(roomid, response['data']['message'], richmessage=response['data']['richmessage']):
                logger.debug("Result of sending message:\n\t%s", retval)
                retval = True
            else:
                logger.warning("There was a problem sending a message.  Check logfile for details")
        elif response['responseType'] == 'file':
            """
            The package returned a locally-stored file attachment to be sent to the user.  Try to send it and
            then remove the temporary file if successfully attached.
            """
            uploadresult = teamobj.attachFile(roomid, response['data']['file'], response['data']['message'])
            if uploadresult == False:
                logger.warning("Failed to send file attachment.\n\tRoom: %s\n\tFile: %s\n\tMessage: %s",
                               roomid,
                               response['data']['file'],
                               response['data']['message']
                               )
                errormsg = "{}\nThere was a problem posting the file.".format('\U0001F92E')
                errormsg += "The error message is:\n{}".format(uploadresult)

                errmsgrich = "{}\n\nThere was a problem posting the file.".format('\U0001F92E')
                errmsgrich += "The error message is:\n\n{}".format(response['data']['richmessage'])

                teamobj.sendMessage(roomid, errormsg, richmessage=errmsgrich)
            else:
                logger.debug("File uploaded successfully.\n\tRoom ID: %s\n\tFilename: %s", roomid, response['data']['file'])
                removeFile(response['data']['file'])
                retval = True
    else:
        logger.warning("Invalid response received in parseResponse.  Check log for details")
        errmsg = "{}\nThere was a problem performing the requested task.".format('\U0001F92E')
        errmsgrich = "{}\n\nThere was a performing the requested task.".format('\U0001F92E')
        teamobj.sendMessage(roomid, errmsg, richmessage=errmsgrich)

    return retval


""" 
END Function definitions
/**********************************************************************************************************************
"""

"""
/**********************************************************************************************************************
BEGIN Webhook processing
When messages come in from the webhook, they are processed here.  The message text needs to be retrieved from
the calling webhook and directed to the appropriate package / method for processing.  We will rely on the packages
themselves to take appropriate action based on the received message.

This is designed to be extensible, so different classes may be used depending on the URL in the POST.  For example,
we can define multiple bot handlers from Webex Teams and use differing URLs beginning with '/api/teams/' where the
final component invokes a different bot and does (something)

Future packages may include webhook processing from Cisco DNA Center - perhaps using '/api/cisco/dna' or '/api/dnac'
or similar.  This would enable messages sent from Cisco DNA to be processes and an appropriate response be taken - 
send a message to a room or group in Webex Teams, create a ServiceNOW request, or ???
"""


@app.route('/api/teams/dna', methods=['POST'])
def index():
    """
    Handler for the Webex Teams / Cisco DNA Center integration.
    Processes incoming messages, obtain keywords, and call the proper methods from the
    CiscoDNA.dnaCenter class.  Results will be sent back to the requester.

    :return: string value "success" if all tasks succeed, "failure" otherwise.
    """
    retval = "failure"

    """
    Initial steps:
    - Set the botname for this app.  This will enable the webexTeams class to load the correct config values
    - Get the raw request from the webhook - this will be used to validate the incoming message
    - Set a variable to hold the JSON POST data
    """
    botname = "dnabot"
    raw = request.data.decode("utf-8")
    postdata = json.loads(raw)

    """
    Instantiate a new 'webexTeams' object named 'teams' and begin processing the message:
    - Validate the incoming message
    - If the message is valid, extract the room ID (for message replies) and the message text which will be
      passed to the dnaCenter class for processing
    """
    with CiscoWebex.webexTeams.webexTeams(botname, tmp=apiConfig.tmpdir) as teams:
        if teams.validateMessage(raw, request.headers):
            # The message is valid, proceed...
            logger.debug("Message is valid, proceeding...")

            # Extract necessary data
            roomid = postdata['data']['roomId']
            logger.debug("Room ID from received message: %s", roomid)
            messageid = postdata['data']['id']
            logger.debug("Message ID from received message: %s", messageid)

            # Get the message text.  If there's a problem retrieving it, do not pass go.
            messagetext = teams.getMessage(messageid)
            if messagetext != False:
                """
                We have passed go and collected $200.  Proceed by converting the message to lowercase, sending a
                reply to the Webex Teams response saying that the request is being processed, and send the message
                to a new dnaCenter object for processing.
                
                Once a the message has been processed, a data structure will be returned and sent to the 'parseResponse'
                function to generate the proper Webex Teams response
                """
                messagetext = messagetext.get('text', '').lower()
                messagetext = messagetext.replace(teams.myBotName().lower(), '').lstrip()
                logger.debug("Message text received: %s", messagetext)

                teams.sendMessage(roomid, "Let me work on that... \U0001F557")
                """
                The generic "please wait" message has been send.  Create a new dnaCenter object and pass
                some of our info to it.  Right now, that means the name of the logger so we can receive logging
                and the temporary directory to store any generated attachments
                """
                with CiscoDNA.dnaCenter.dnaCenter(logname=apiConfig.logname, tmp=apiConfig.tmpdir) as dna:
                    # Send the received message to the dna object and send the response to 'parseResponse'
                    dnaresponse = dna.parseTeamsMessage(messagetext)
                    r = parseResponse(teams, roomid, dnaresponse)
                    if r:
                        retval = "success"
        else:
            logger.warning("Invalid message received, ignoring")

    return retval


"""
END Webhook processing
/**********************************************************************************************************************
"""

if __name__ == '__main__':
    """
    Run the Flask app.  By default, will listen on all local IP addresses on port 5000.
    __main__ will only be executed if this script is being run interactively.  If the UWSGI app server
    is used, the Flask app routing will take place directly above and will listen for the specified
    HTTP API calls...
    """
    app.run(host='0.0.0.0', debug=True)
